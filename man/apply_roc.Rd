% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_roc.R
\name{apply_roc}
\alias{apply_roc}
\title{Calculate ROC objects for a list of data sets}
\usage{
apply_roc(
  milist,
  selection,
  response,
  predictor,
  direction = ">",
  levels = c(0, 1),
  algorithm = 6,
  quiet = FALSE,
  auc = TRUE
)
}
\arguments{
\item{milist}{List of data.frames}

\item{selection}{either "all" if roc object should be returned for every 
element in milist, or an integer vector containing the indices of the elements 
in milist to use (for example when the first element contains the original 
data with missing values)}

\item{response}{Character, the name of the response variable that must be 
available in each data.frame in milist.}

\item{predictor}{Character, the name of the predictor variable that must be 
available in each data.frame in milist.}

\item{direction}{either "<" or ">". "auto" is not supported because it might 
be different by imputation. By default ">".}

\item{levels}{the value of the response for controls and cases respectively. 
By default, the first two values of levels(as.factor(response)) are taken, 
and the remaining levels are ignored. It usually captures two-class factor 
data correctly, but will frequently fail for other data types (response 
factor with more than 2 levels, or for example if your response is coded 
“controls” and “cases”, the levels will be inverted) and must then be 
specified here. If your data is coded as 0 and 1 with 0 being the controls, 
you can safely omit this argument. With several data frames it is recommended 
you set this value explicitly, otherwise it will be determined for each data 
set separately.}

\item{algorithm}{the method used to compute sensitivity and specificity, an 
integer of length 1 between 0 and 6. 1: a safe, well-tested, pure-R code that 
is efficient when the number of thresholds is low. It goes with O(T*N). 2: 
an alternative pure-R algorithm that goes in O(N). Typically faster than 1 
when the number of thresholds of the ROC curve is above 1000. Less tested 
than 1. 3: a C++ implementation of 1, about 3-5x faster. Typically the 
fastest with ROC curves with less than 50-100 thresholds, but has a very 
bad worst-case when that number increases. 4 (debug only, slow): runs 
algorithms 1 to 3 and makes sure they return the same values. 5: select 2 
or 3 based on the number of thresholds. 6 (default): quickly select the 
algorithm on the class of the data: 2 for numeric and 3 for ordered. 0: 
use microbenchmark to choose between 2 and 3. By default 6.}

\item{quiet}{set to TRUE to turn off messages when levels is auto-detected.}

\item{auc}{compute the area under the curve (AUC)? TRUE by default.}
}
\value{
A list of `pROC::roc` objects
}
\description{
Simple convenience function to apply `pROC::roc` over a list of data sets with 
multiple imputations. You could do it using `map` or `apply` or `with`,
but this is just a bit easier. It does not allow for smoothed ROC curves.
}
\details{
For more details on the arguments see `pROC::roc`.
}
